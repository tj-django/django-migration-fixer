{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"django-migration-fixer Maintain a consistent migration history when conflicts occur as a result of changes made using different versions of the default branch. Installation $ pip install django-migration-fixer Add migration_fixer to your INSTALLED_APPS INSTALLED_APPS = [ ... , \"migration_fixer\" , ... , ] Usage $ python manage.py makemigrations --fix By default this uses main as the default branch For specifying a different default branch Run: $ python manage.py makemigrations -b master --fix Features Resolve migration conflicts on PR branches Resolve migration conflicts on the default branch (NOT RECOMMENDED) Supports default migration modules i.e ( 0001_....py ) Supports named migration modules i.e ( custom_migration.py ) Re-nummber all migrations using the last migration on the default branch i.e main or develop Example Branch: main \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py Branch: feature/test-a \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1228.py Both feature/test-a and feature/test-b share the last migration on main ( 0002_auto_20210521_2328.py ) Once feature/test-a is merged into main you run into the problem of resolving migrations on feature/test-b which was dependent on 0002_auto_20210521_2328.py Branch: main \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py \\_ __________________ Both dependent on 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1228.py / Running makemigrations fails with the following error: CommandError: Conflicting migrations detected; multiple leaf nodes in the migration graph: (0003_auto_20210522_1128, 0003_auto_20210522_1228 in app). To fix them run 'python manage.py makemigrations --merge' Using the --merge option creates a new migration file which might not be desired. Solution django-migration-fixer identifies changes between the default branch main , and the feature branch feature/test-b and maintains a consistent dependency history as shown below: Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py \u2502 \u251c\u2500\u2500 0004_auto_20210522_1228.py # Renames: '0003_auto_20210522_1228.py' \u2192 '0004_auto_20210522_1228.py' 0004_auto_20210522_1228.py ... from django.db import migrations , models class Migration ( migrations . Migration ): dependencies = [ ( 'app' , '0003_auto_20210522_1128' ), # Replaced '0002_auto_20210521_2328' \u2192 '0003_auto_20210522_1128' ] operations = [ ... ] NOTE: :warning: This also works when there are conflicts detected on the default branch. i.e You can run python manage.py makemigrations --fix on the main branch which relies on primitively picking the first migration file. e.g (0003_auto_20210522_1128, 0003_auto_20210522_1228 in app) would result in 0003_auto_20210522_1128.py being picked as the base migration which might not be accurate in every case and is not recommended. Assumptions The final migration on the default branch would be used as the base for all subsequent migrations.","title":"Home"},{"location":"index.html#django-migration-fixer","text":"Maintain a consistent migration history when conflicts occur as a result of changes made using different versions of the default branch.","title":"django-migration-fixer"},{"location":"index.html#installation","text":"$ pip install django-migration-fixer","title":"Installation"},{"location":"index.html#add-migration_fixer-to-your-installed_apps","text":"INSTALLED_APPS = [ ... , \"migration_fixer\" , ... , ]","title":"Add migration_fixer to your INSTALLED_APPS"},{"location":"index.html#usage","text":"$ python manage.py makemigrations --fix By default this uses main as the default branch","title":"Usage"},{"location":"index.html#for-specifying-a-different-default-branch","text":"Run: $ python manage.py makemigrations -b master --fix","title":"For specifying a different default branch"},{"location":"index.html#features","text":"Resolve migration conflicts on PR branches Resolve migration conflicts on the default branch (NOT RECOMMENDED) Supports default migration modules i.e ( 0001_....py ) Supports named migration modules i.e ( custom_migration.py ) Re-nummber all migrations using the last migration on the default branch i.e main or develop","title":"Features"},{"location":"index.html#example","text":"Branch: main \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py Branch: feature/test-a \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1228.py Both feature/test-a and feature/test-b share the last migration on main ( 0002_auto_20210521_2328.py ) Once feature/test-a is merged into main you run into the problem of resolving migrations on feature/test-b which was dependent on 0002_auto_20210521_2328.py Branch: main \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py \\_ __________________ Both dependent on 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1228.py / Running makemigrations fails with the following error: CommandError: Conflicting migrations detected; multiple leaf nodes in the migration graph: (0003_auto_20210522_1128, 0003_auto_20210522_1228 in app). To fix them run 'python manage.py makemigrations --merge' Using the --merge option creates a new migration file which might not be desired.","title":"Example"},{"location":"index.html#solution","text":"django-migration-fixer identifies changes between the default branch main , and the feature branch feature/test-b and maintains a consistent dependency history as shown below: Branch: feature/test-b \u251c\u2500\u2500 app \u2502 \u251c\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_auto_20210521_2328.py \u2502 \u251c\u2500\u2500 0003_auto_20210522_1128.py \u2502 \u251c\u2500\u2500 0004_auto_20210522_1228.py # Renames: '0003_auto_20210522_1228.py' \u2192 '0004_auto_20210522_1228.py' 0004_auto_20210522_1228.py ... from django.db import migrations , models class Migration ( migrations . Migration ): dependencies = [ ( 'app' , '0003_auto_20210522_1128' ), # Replaced '0002_auto_20210521_2328' \u2192 '0003_auto_20210522_1128' ] operations = [ ... ] NOTE: :warning: This also works when there are conflicts detected on the default branch. i.e You can run python manage.py makemigrations --fix on the main branch which relies on primitively picking the first migration file. e.g (0003_auto_20210522_1128, 0003_auto_20210522_1228 in app) would result in 0003_auto_20210522_1128.py being picked as the base migration which might not be accurate in every case and is not recommended.","title":"Solution"},{"location":"index.html#assumptions","text":"The final migration on the default branch would be used as the base for all subsequent migrations.","title":"Assumptions"},{"location":"CHANGELOG.html","text":"Changelog v0.0.7 (2021-06-21) Full Changelog Closed issues: Dependency Dashboard #40 Merged pull requests: Updated README.md #46 ( jackton1 ) Update README.md #45 ( jackton1 ) Updated README.md #44 ( jackton1 ) Improve test coverage #43 ( jackton1 ) [pre-commit.ci] pre-commit autoupdate #42 ( pre-commit-ci[bot] ) Update wearerequired/lint-action action to v1.10.0 #41 ( renovate[bot] ) Update tj-actions/verify-changed-files action to v6.2 #39 ( renovate[bot] ) Update dependency portray to v1.7.0 #38 ( renovate[bot] ) Update dependency mkdocs to v1.2.1 #37 ( renovate[bot] ) Update codecov/codecov-action action to v1.5.2 #36 ( renovate[bot] ) Update actions/cache action to v2.1.6 #35 ( renovate[bot] ) Upgraded v0.0.5 \u2192 v0.0.6 #33 ( jackton1 ) Updated README.md #32 ( jackton1 ) v0.0.6 (2021-06-08) Full Changelog Closed issues: Initial Update #24 Add documentation #18 subprocess call - check for execution of untrusted input. #10 Merged pull requests: Updated README.md #31 ( jackton1 ) Pin django to latest version 3.2.4 #26 ( pyup-bot ) Config file for pyup.io #25 ( pyup-bot ) Updated README.md #21 ( jackton1 ) Updated README.md #20 ( jackton1 ) Added documentation #19 ( jackton1 ) Remove pytest-runner #15 ( jackton1 ) Added mypy configuration and updated tox test. #14 ( jackton1 ) Added action to run makemigrations --fix #13 ( jackton1 ) [Cleanup]: Code duplication #12 ( jackton1 ) [Security]: Fix security issue using subprocess #11 ( jackton1 ) Upgraded v0.0.4 \u2192 v0.0.5 #9 ( jackton1 ) v0.0.5 (2021-05-24) Full Changelog v0.0.4 (2021-05-24) Full Changelog v0.0.3 (2021-05-24) Full Changelog Merged pull requests: chore/update deployment #8 ( jackton1 ) Added bumpversion configuration. #7 ( jackton1 ) Update README.md #6 ( jackton1 ) v0.0.2 (2021-05-23) Full Changelog Closed issues: Install instructions say \"pip install django-view-breadcrumbs\" #5 v0.0.1 (2021-05-23) Full Changelog Merged pull requests: Update README.md #4 ( jackton1 ) Create LICENSE #3 ( jackton1 ) Added named migration. #2 ( jackton1 ) Increased the max_length to 500. #1 ( jackton1 ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG.html#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG.html#v007-2021-06-21","text":"Full Changelog Closed issues: Dependency Dashboard #40 Merged pull requests: Updated README.md #46 ( jackton1 ) Update README.md #45 ( jackton1 ) Updated README.md #44 ( jackton1 ) Improve test coverage #43 ( jackton1 ) [pre-commit.ci] pre-commit autoupdate #42 ( pre-commit-ci[bot] ) Update wearerequired/lint-action action to v1.10.0 #41 ( renovate[bot] ) Update tj-actions/verify-changed-files action to v6.2 #39 ( renovate[bot] ) Update dependency portray to v1.7.0 #38 ( renovate[bot] ) Update dependency mkdocs to v1.2.1 #37 ( renovate[bot] ) Update codecov/codecov-action action to v1.5.2 #36 ( renovate[bot] ) Update actions/cache action to v2.1.6 #35 ( renovate[bot] ) Upgraded v0.0.5 \u2192 v0.0.6 #33 ( jackton1 ) Updated README.md #32 ( jackton1 )","title":"v0.0.7 (2021-06-21)"},{"location":"CHANGELOG.html#v006-2021-06-08","text":"Full Changelog Closed issues: Initial Update #24 Add documentation #18 subprocess call - check for execution of untrusted input. #10 Merged pull requests: Updated README.md #31 ( jackton1 ) Pin django to latest version 3.2.4 #26 ( pyup-bot ) Config file for pyup.io #25 ( pyup-bot ) Updated README.md #21 ( jackton1 ) Updated README.md #20 ( jackton1 ) Added documentation #19 ( jackton1 ) Remove pytest-runner #15 ( jackton1 ) Added mypy configuration and updated tox test. #14 ( jackton1 ) Added action to run makemigrations --fix #13 ( jackton1 ) [Cleanup]: Code duplication #12 ( jackton1 ) [Security]: Fix security issue using subprocess #11 ( jackton1 ) Upgraded v0.0.4 \u2192 v0.0.5 #9 ( jackton1 )","title":"v0.0.6 (2021-06-08)"},{"location":"CHANGELOG.html#v005-2021-05-24","text":"Full Changelog","title":"v0.0.5 (2021-05-24)"},{"location":"CHANGELOG.html#v004-2021-05-24","text":"Full Changelog","title":"v0.0.4 (2021-05-24)"},{"location":"CHANGELOG.html#v003-2021-05-24","text":"Full Changelog Merged pull requests: chore/update deployment #8 ( jackton1 ) Added bumpversion configuration. #7 ( jackton1 ) Update README.md #6 ( jackton1 )","title":"v0.0.3 (2021-05-24)"},{"location":"CHANGELOG.html#v002-2021-05-23","text":"Full Changelog Closed issues: Install instructions say \"pip install django-view-breadcrumbs\" #5","title":"v0.0.2 (2021-05-23)"},{"location":"CHANGELOG.html#v001-2021-05-23","text":"Full Changelog Merged pull requests: Update README.md #4 ( jackton1 ) Create LICENSE #3 ( jackton1 ) Added named migration. #2 ( jackton1 ) Increased the max_length to 500. #1 ( jackton1 ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.0.1 (2021-05-23)"},{"location":"reference/migration_fixer/management/index.html","text":"Module migration_fixer.management Top level management package for migration_fixer. None View Source \"\"\" Top level management package for migration_fixer. \"\"\" Sub-modules migration_fixer.management.commands","title":"Index"},{"location":"reference/migration_fixer/management/index.html#module-migration_fixermanagement","text":"Top level management package for migration_fixer. None View Source \"\"\" Top level management package for migration_fixer. \"\"\"","title":"Module migration_fixer.management"},{"location":"reference/migration_fixer/management/index.html#sub-modules","text":"migration_fixer.management.commands","title":"Sub-modules"},{"location":"reference/migration_fixer/management/commands/index.html","text":"Module migration_fixer.management.commands Top level commands package for migration_fixer. None View Source \"\"\" Top level commands package for migration_fixer. \"\"\" Sub-modules migration_fixer.management.commands.makemigrations","title":"Index"},{"location":"reference/migration_fixer/management/commands/index.html#module-migration_fixermanagementcommands","text":"Top level commands package for migration_fixer. None View Source \"\"\" Top level commands package for migration_fixer. \"\"\"","title":"Module migration_fixer.management.commands"},{"location":"reference/migration_fixer/management/commands/index.html#sub-modules","text":"migration_fixer.management.commands.makemigrations","title":"Sub-modules"},{"location":"reference/migration_fixer/management/commands/makemigrations.html","text":"Module migration_fixer.management.commands.makemigrations Create a new django migration with support for fixing conflicts. None View Source \"\"\" Create a new django migration with support for fixing conflicts. \"\"\" import os import pathlib from django.apps import apps from django.conf import settings from django.core.management.base import CommandError from django.core.management.commands.makemigrations import Command as BaseCommand from django.db import DEFAULT_DB_ALIAS, connections, router from django.db.migrations.loader import MigrationLoader from migration_fixer.utils import ( fix_migration, fix_numbered_migration, no_translations, run_command, ) class Command(BaseCommand): success_msg = \"Successfully fixed migrations.\" def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser) @no_translations def handle(self, *app_labels, **options): self.merge = options[\"merge\"] self.fix = options[\"fix\"] self.default_branch = options[\"default_branch\"] if self.fix: try: super().handle(*app_labels, **options) except CommandError as e: [message] = e.args if \"Conflicting migrations\" in message: git_setup, git_setup_output, git_setup_error = run_command( \"git status\" ) if not git_setup: raise CommandError( self.style.ERROR( f\"VCS is not yet setup. \" \"Please run (git init) \" f'\\n\"{git_setup_output or git_setup_error}\"' ) ) ( get_current_branch, get_current_branch_output, get_current_branch_error, ) = run_command(\"git branch --show-current\") if not get_current_branch: raise CommandError( self.style.ERROR( f\"Unable to determine the current branch: \" f'\"{get_current_branch_output or get_current_branch_error}\"' ) ) pull_command = ( \"git pull\" if get_current_branch_output == self.default_branch else ( \"git fetch --depth=1 origin \" f\"{self.default_branch}:{self.default_branch}\" ) ) # Pull the last commit git_pull, git_pull_output, git_pull_error = run_command( pull_command ) if not git_pull: raise CommandError( self.style.ERROR( f\"Error pulling branch ({self.default_branch}) changes: \" f'\"{git_pull_output or git_pull_error}\"' ) ) head_sha, head_sha_output, head_sha_error = run_command( f\"git rev-parse {self.default_branch}\" ) if not head_sha: raise CommandError( self.style.ERROR( f\"Error determining head sha on ({self.default_branch}): \" f'\"{head_sha_output or head_sha_error}\"' ) ) # Load the current graph state. Pass in None for the connection so # the loader doesn't try to resolve replaced migrations from DB. loader = MigrationLoader(None, ignore_no_migrations=True) # Raise an error if any migrations are applied before their dependencies. consistency_check_labels = { config.label for config in apps.get_app_configs() } # Non-default databases are only checked if database routers used. aliases_to_check = ( connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS] ) for alias in sorted(aliases_to_check): connection = connections[alias] if connection.settings_dict[ \"ENGINE\" ] != \"django.db.backends.dummy\" and any( # At least one model must be migrated to the database. router.allow_migrate( connection.alias, app_label, model_name=model._meta.object_name, ) for app_label in consistency_check_labels for model in apps.get_app_config(app_label).get_models() ): loader.check_consistent_history(connection) # Before anything else, see if there's conflicting apps and drop out # hard if there are any and they don't want to merge conflicts = loader.detect_conflicts() app_labels = app_labels or tuple( app_label for app_label in settings.INSTALLED_APPS if app_label in conflicts ) for app_label in app_labels: conflict = conflicts.get(app_label) migration_module, _ = loader.migrations_module(app_label) migration_absolute_path = os.path.join( *migration_module.split(\".\") ) migration_path = pathlib.Path( os.path.join(settings.BASE_DIR, migration_absolute_path) ) with migration_path: ( get_changed_files, get_changed_files_output, get_changed_files_error, ) = run_command( f\"git diff --diff-filter=ACMUXTR --name-only {self.default_branch}\" ) if not get_changed_files: raise CommandError( self.style.ERROR( \"Error retrieving changed files on \" f\"({self.default_branch}): \" f'\"{get_changed_files_output or get_changed_files_error}\"' ) ) # Files different on the current branch changed_files = [ fname for fname in get_changed_files_output.split(\"\\n\") if migration_absolute_path in fname ] # Local migration local_filenames = [ os.path.splitext(os.path.basename(p))[0] for p in changed_files ] last_remote = [ fname for fname in conflict if fname not in local_filenames ] if not last_remote: raise CommandError( self.style.ERROR( f\"Unable to determine the last migration on: \" f\"{self.default_branch}\", ) ) last_remote_filename, *rest = last_remote changed_files = changed_files or [ f\"{fname}.py\" for fname in rest ] seed_split = last_remote_filename.split(\"_\") try: if ( seed_split and len(seed_split) > 1 and str(seed_split[0]).isdigit() ): fix_numbered_migration( app_label=app_label, migration_path=migration_path, seed=int(seed_split[0]), start_name=last_remote_filename, changed_files=changed_files, ) else: fix_migration( app_label=app_label, migration_path=migration_path, start_name=last_remote_filename, changed_files=changed_files, ) except (ValueError, IndexError, TypeError) as e: self.stderr.write(f\"Error: {e}\") else: self.stdout.write(self.success_msg) else: return super(Command, self).handle(*app_labels, **options) Variables DEFAULT_DB_ALIAS Classes Command class Command ( stdout = None , stderr = None , no_color = False , force_color = False ) View Source class Command(BaseCommand): success_msg = \"Successfully fixed migrations.\" def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser) @no_translations def handle(self, *app_labels, **options): self.merge = options[\"merge\"] self.fix = options[\"fix\"] self.default_branch = options[\"default_branch\"] if self.fix: try: super().handle(*app_labels, **options) except CommandError as e: [message] = e.args if \"Conflicting migrations\" in message: git_setup, git_setup_output, git_setup_error = run_command( \"git status\" ) if not git_setup: raise CommandError( self.style.ERROR( f\"VCS is not yet setup. \" \"Please run (git init) \" f'\\n\"{git_setup_output or git_setup_error}\"' ) ) ( get_current_branch, get_current_branch_output, get_current_branch_error, ) = run_command(\"git branch --show-current\") if not get_current_branch: raise CommandError( self.style.ERROR( f\"Unable to determine the current branch: \" f'\"{get_current_branch_output or get_current_branch_error}\"' ) ) pull_command = ( \"git pull\" if get_current_branch_output == self.default_branch else ( \"git fetch --depth=1 origin \" f\"{self.default_branch}:{self.default_branch}\" ) ) # Pull the last commit git_pull, git_pull_output, git_pull_error = run_command( pull_command ) if not git_pull: raise CommandError( self.style.ERROR( f\"Error pulling branch ({self.default_branch}) changes: \" f'\"{git_pull_output or git_pull_error}\"' ) ) head_sha, head_sha_output, head_sha_error = run_command( f\"git rev-parse {self.default_branch}\" ) if not head_sha: raise CommandError( self.style.ERROR( f\"Error determining head sha on ({self.default_branch}): \" f'\"{head_sha_output or head_sha_error}\"' ) ) # Load the current graph state. Pass in None for the connection so # the loader doesn't try to resolve replaced migrations from DB. loader = MigrationLoader(None, ignore_no_migrations=True) # Raise an error if any migrations are applied before their dependencies. consistency_check_labels = { config.label for config in apps.get_app_configs() } # Non-default databases are only checked if database routers used. aliases_to_check = ( connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS] ) for alias in sorted(aliases_to_check): connection = connections[alias] if connection.settings_dict[ \"ENGINE\" ] != \"django.db.backends.dummy\" and any( # At least one model must be migrated to the database. router.allow_migrate( connection.alias, app_label, model_name=model._meta.object_name, ) for app_label in consistency_check_labels for model in apps.get_app_config(app_label).get_models() ): loader.check_consistent_history(connection) # Before anything else, see if there's conflicting apps and drop out # hard if there are any and they don't want to merge conflicts = loader.detect_conflicts() app_labels = app_labels or tuple( app_label for app_label in settings.INSTALLED_APPS if app_label in conflicts ) for app_label in app_labels: conflict = conflicts.get(app_label) migration_module, _ = loader.migrations_module(app_label) migration_absolute_path = os.path.join( *migration_module.split(\".\") ) migration_path = pathlib.Path( os.path.join(settings.BASE_DIR, migration_absolute_path) ) with migration_path: ( get_changed_files, get_changed_files_output, get_changed_files_error, ) = run_command( f\"git diff --diff-filter=ACMUXTR --name-only {self.default_branch}\" ) if not get_changed_files: raise CommandError( self.style.ERROR( \"Error retrieving changed files on \" f\"({self.default_branch}): \" f'\"{get_changed_files_output or get_changed_files_error}\"' ) ) # Files different on the current branch changed_files = [ fname for fname in get_changed_files_output.split(\"\\n\") if migration_absolute_path in fname ] # Local migration local_filenames = [ os.path.splitext(os.path.basename(p))[0] for p in changed_files ] last_remote = [ fname for fname in conflict if fname not in local_filenames ] if not last_remote: raise CommandError( self.style.ERROR( f\"Unable to determine the last migration on: \" f\"{self.default_branch}\", ) ) last_remote_filename, *rest = last_remote changed_files = changed_files or [ f\"{fname}.py\" for fname in rest ] seed_split = last_remote_filename.split(\"_\") try: if ( seed_split and len(seed_split) > 1 and str(seed_split[0]).isdigit() ): fix_numbered_migration( app_label=app_label, migration_path=migration_path, seed=int(seed_split[0]), start_name=last_remote_filename, changed_files=changed_files, ) else: fix_migration( app_label=app_label, migration_path=migration_path, start_name=last_remote_filename, changed_files=changed_files, ) except (ValueError, IndexError, TypeError) as e: self.stderr.write(f\"Error: {e}\") else: self.stdout.write(self.success_msg) else: return super(Command, self).handle(*app_labels, **options) Ancestors (in MRO) django.core.management.commands.makemigrations.Command django.core.management.base.BaseCommand Class variables base_stealth_options help output_transaction requires_migrations_checks requires_system_checks stealth_options success_msg Methods add_arguments def add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. View Source def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser) check def check ( self , app_configs = None , tags = None , display_num_errors = False , include_deployment_checks = False , fail_level = 40 , databases = None ) Use the system check framework to validate entire Django project. Raise CommandError for any serious message (error or critical errors). If there are only light messages (like warnings), print them to stderr and don't raise an exception. View Source def check(self, app_configs=None, tags=None, display_num_errors=False, include_deployment_checks=False, fail_level=checks.ERROR, databases=None): \"\"\" Use the system check framework to validate entire Django project. Raise CommandError for any serious message (error or critical errors). If there are only light messages (like warnings), print them to stderr and don't raise an exception. \"\"\" all_issues = checks.run_checks( app_configs=app_configs, tags=tags, include_deployment_checks=include_deployment_checks, databases=databases, ) header, body, footer = \"\", \"\", \"\" visible_issue_count = 0 # excludes silenced warnings if all_issues: debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()] infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()] warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()] errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()] criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()] sorted_issues = [ (criticals, 'CRITICALS'), (errors, 'ERRORS'), (warnings, 'WARNINGS'), (infos, 'INFOS'), (debugs, 'DEBUGS'), ] for issues, group_name in sorted_issues: if issues: visible_issue_count += len(issues) formatted = ( self.style.ERROR(str(e)) if e.is_serious() else self.style.WARNING(str(e)) for e in issues) formatted = \"\\n\".join(sorted(formatted)) body += '\\n%s:\\n%s\\n' % (group_name, formatted) if visible_issue_count: header = \"System check identified some issues:\\n\" if display_num_errors: if visible_issue_count: footer += '\\n' footer += \"System check identified %s (%s silenced).\" % ( \"no issues\" if visible_issue_count == 0 else \"1 issue\" if visible_issue_count == 1 else \"%s issues\" % visible_issue_count, len(all_issues) - visible_issue_count, ) if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues): msg = self.style.ERROR(\"SystemCheckError: %s\" % header) + body + footer raise SystemCheckError(msg) else: msg = header + body + footer if msg: if visible_issue_count: self.stderr.write(msg, lambda x: x) else: self.stdout.write(msg) check_migrations def check_migrations ( self ) Print a warning if the set of migrations on disk don't match the migrations in the database. View Source def check_migrations(self): \"\"\" Print a warning if the set of migrations on disk don't match the migrations in the database. \"\"\" from django.db.migrations.executor import MigrationExecutor try: executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS]) except ImproperlyConfigured: # No databases are configured (or the dummy one) return plan = executor.migration_plan(executor.loader.graph.leaf_nodes()) if plan: apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan}) self.stdout.write( self.style.NOTICE( \"\\nYou have %(unapplied_migration_count)s unapplied migration(s). \" \"Your project may not work properly until you apply the \" \"migrations for app(s): %(apps_waiting_migration)s.\" % { \"unapplied_migration_count\": len(plan), \"apps_waiting_migration\": \", \".join(apps_waiting_migration), } ) ) self.stdout.write(self.style.NOTICE(\"Run 'python manage.py migrate' to apply them.\")) create_parser def create_parser ( self , prog_name , subcommand , ** kwargs ) Create and return the ArgumentParser which will be used to parse the arguments to this command. View Source def create_parser(self, prog_name, subcommand, **kwargs): \"\"\" Create and return the ``ArgumentParser`` which will be used to parse the arguments to this command. \"\"\" parser = CommandParser( prog='%s %s' % (os.path.basename(prog_name), subcommand), description=self.help or None, formatter_class=DjangoHelpFormatter, missing_args_message=getattr(self, 'missing_args_message', None), called_from_command_line=getattr(self, '_called_from_command_line', None), **kwargs ) parser.add_argument('--version', action='version', version=self.get_version()) parser.add_argument( '-v', '--verbosity', default=1, type=int, choices=[0, 1, 2, 3], help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output', ) parser.add_argument( '--settings', help=( 'The Python path to a settings module, e.g. ' '\"myproject.settings.main\". If this isn\\'t provided, the ' 'DJANGO_SETTINGS_MODULE environment variable will be used.' ), ) parser.add_argument( '--pythonpath', help='A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".', ) parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions') parser.add_argument( '--no-color', action='store_true', help=\"Don't colorize the command output.\", ) parser.add_argument( '--force-color', action='store_true', help='Force colorization of the command output.', ) if self.requires_system_checks: parser.add_argument( '--skip-checks', action='store_true', help='Skip system checks.', ) self.add_arguments(parser) return parser execute def execute ( self , * args , ** options ) Try to execute this command, performing system checks if needed (as controlled by the requires_system_checks attribute, except if force-skipped). View Source def execute(self, *args, **options): \"\"\" Try to execute this command, performing system checks if needed (as controlled by the ``requires_system_checks`` attribute, except if force-skipped). \"\"\" if options['force_color'] and options['no_color']: raise CommandError(\"The --no-color and --force-color options can't be used together.\") if options['force_color']: self.style = color_style(force_color=True) elif options['no_color']: self.style = no_style() self.stderr.style_func = None if options.get('stdout'): self.stdout = OutputWrapper(options['stdout']) if options.get('stderr'): self.stderr = OutputWrapper(options['stderr']) if self.requires_system_checks and not options['skip_checks']: if self.requires_system_checks == ALL_CHECKS: self.check() else: self.check(tags=self.requires_system_checks) if self.requires_migrations_checks: self.check_migrations() output = self.handle(*args, **options) if output: if self.output_transaction: connection = connections[options.get('database', DEFAULT_DB_ALIAS)] output = '%s\\n%s\\n%s' % ( self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()), output, self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()), ) self.stdout.write(output) return output get_version def get_version ( self ) Return the Django version, which should be correct for all built-in Django commands. User-supplied commands can override this method to return their own version. View Source def get_version(self): \"\"\" Return the Django version, which should be correct for all built-in Django commands. User-supplied commands can override this method to return their own version. \"\"\" return django.get_version() handle def handle ( * args , ** kwargs ) View Source def wrapped(*args, **kwargs): from django.utils import translation saved_locale = translation.get_language() translation.deactivate_all() try: res = handle_func(*args, **kwargs) finally: if saved_locale is not None: translation.activate(saved_locale) return res handle_merge def handle_merge ( self , loader , conflicts ) Handles merging together conflicted migrations interactively, if it's safe; otherwise, advises on how to fix it. View Source def handle_merge(self, loader, conflicts): \"\"\" Handles merging together conflicted migrations interactively, if it's safe; otherwise, advises on how to fix it. \"\"\" if self.interactive: questioner = InteractiveMigrationQuestioner() else: questioner = MigrationQuestioner(defaults={'ask_merge': True}) for app_label, migration_names in conflicts.items(): # Grab out the migrations in question, and work out their # common ancestor. merge_migrations = [] for migration_name in migration_names: migration = loader.get_migration(app_label, migration_name) migration.ancestry = [ mig for mig in loader.graph.forwards_plan((app_label, migration_name)) if mig[0] == migration.app_label ] merge_migrations.append(migration) def all_items_equal(seq): return all(item == seq[0] for item in seq[1:]) merge_migrations_generations = zip(*(m.ancestry for m in merge_migrations)) common_ancestor_count = sum(1 for common_ancestor_generation in takewhile(all_items_equal, merge_migrations_generations)) if not common_ancestor_count: raise ValueError(\"Could not find common ancestor of %s\" % migration_names) # Now work out the operations along each divergent branch for migration in merge_migrations: migration.branch = migration.ancestry[common_ancestor_count:] migrations_ops = (loader.get_migration(node_app, node_name).operations for node_app, node_name in migration.branch) migration.merged_operations = sum(migrations_ops, []) # In future, this could use some of the Optimizer code # (can_optimize_through) to automatically see if they're # mergeable. For now, we always just prompt the user. if self.verbosity > 0: self.stdout.write(self.style.MIGRATE_HEADING(\"Merging %s\" % app_label)) for migration in merge_migrations: self.stdout.write(self.style.MIGRATE_LABEL(\" Branch %s\" % migration.name)) for operation in migration.merged_operations: self.stdout.write(' - %s' % operation.describe()) if questioner.ask_merge(app_label): # If they still want to merge it, then write out an empty # file depending on the migrations needing merging. numbers = [ MigrationAutodetector.parse_number(migration.name) for migration in merge_migrations ] try: biggest_number = max(x for x in numbers if x is not None) except ValueError: biggest_number = 1 subclass = type(\"Migration\", (Migration,), { \"dependencies\": [(app_label, migration.name) for migration in merge_migrations], }) parts = ['%04i' % (biggest_number + 1)] if self.migration_name: parts.append(self.migration_name) else: parts.append('merge') leaf_names = '_'.join(sorted(migration.name for migration in merge_migrations)) if len(leaf_names) > 47: parts.append(get_migration_name_timestamp()) else: parts.append(leaf_names) migration_name = '_'.join(parts) new_migration = subclass(migration_name, app_label) writer = MigrationWriter(new_migration, self.include_header) if not self.dry_run: # Write the merge migrations file to the disk with open(writer.path, \"w\", encoding='utf-8') as fh: fh.write(writer.as_string()) if self.verbosity > 0: self.stdout.write(\"\\nCreated new merge migration %s\" % writer.path) elif self.verbosity == 3: # Alternatively, makemigrations --merge --dry-run --verbosity 3 # will output the merge migrations to stdout rather than saving # the file to the disk. self.stdout.write(self.style.MIGRATE_HEADING( \"Full merge migrations file '%s':\" % writer.filename )) self.stdout.write(writer.as_string()) print_help def print_help ( self , prog_name , subcommand ) Print the help message for this command, derived from self.usage() . View Source def print_help(self, prog_name, subcommand): \"\"\" Print the help message for this command, derived from ``self.usage()``. \"\"\" parser = self.create_parser(prog_name, subcommand) parser.print_help() run_from_argv def run_from_argv ( self , argv ) Set up any environment changes requested (e.g., Python path and Django settings), then run this command. If the command raises a CommandError , intercept it and print it sensibly to stderr. If the --traceback option is present or the raised Exception is not CommandError , raise it. View Source def run_from_argv(self, argv): \"\"\" Set up any environment changes requested (e.g., Python path and Django settings), then run this command. If the command raises a ``CommandError``, intercept it and print it sensibly to stderr. If the ``--traceback`` option is present or the raised ``Exception`` is not ``CommandError``, raise it. \"\"\" self._called_from_command_line = True parser = self.create_parser(argv[0], argv[1]) options = parser.parse_args(argv[2:]) cmd_options = vars(options) # Move positional args out of options to mimic legacy optparse args = cmd_options.pop('args', ()) handle_default_options(options) try: self.execute(*args, **cmd_options) except CommandError as e: if options.traceback: raise # SystemCheckError takes care of its own formatting. if isinstance(e, SystemCheckError): self.stderr.write(str(e), lambda x: x) else: self.stderr.write('%s: %s' % (e.__class__.__name__, e)) sys.exit(e.returncode) finally: try: connections.close_all() except ImproperlyConfigured: # Ignore if connections aren't setup at this point (e.g. no # configured settings). pass write_migration_files def write_migration_files ( self , changes ) Take a changes dict and write them out as migration files. View Source def write_migration_files(self, changes): \"\"\" Take a changes dict and write them out as migration files. \"\"\" directory_created = {} for app_label, app_migrations in changes.items(): if self.verbosity >= 1: self.stdout.write(self.style.MIGRATE_HEADING(\"Migrations for '%s':\" % app_label)) for migration in app_migrations: # Describe the migration writer = MigrationWriter(migration, self.include_header) if self.verbosity >= 1: # Display a relative path if it's below the current working # directory, or an absolute path otherwise. try: migration_string = os.path.relpath(writer.path) except ValueError: migration_string = writer.path if migration_string.startswith('..'): migration_string = writer.path self.stdout.write(' %s\\n' % self.style.MIGRATE_LABEL(migration_string)) for operation in migration.operations: self.stdout.write(' - %s' % operation.describe()) if not self.dry_run: # Write the migrations file to the disk. migrations_directory = os.path.dirname(writer.path) if not directory_created.get(app_label): os.makedirs(migrations_directory, exist_ok=True) init_path = os.path.join(migrations_directory, \"__init__.py\") if not os.path.isfile(init_path): open(init_path, \"w\").close() # We just do this once per app directory_created[app_label] = True migration_string = writer.as_string() with open(writer.path, \"w\", encoding='utf-8') as fh: fh.write(migration_string) elif self.verbosity == 3: # Alternatively, makemigrations --dry-run --verbosity 3 # will output the migrations to stdout rather than saving # the file to the disk. self.stdout.write(self.style.MIGRATE_HEADING( \"Full migrations file '%s':\" % writer.filename )) self.stdout.write(writer.as_string())","title":"Makemigrations"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#module-migration_fixermanagementcommandsmakemigrations","text":"Create a new django migration with support for fixing conflicts. None View Source \"\"\" Create a new django migration with support for fixing conflicts. \"\"\" import os import pathlib from django.apps import apps from django.conf import settings from django.core.management.base import CommandError from django.core.management.commands.makemigrations import Command as BaseCommand from django.db import DEFAULT_DB_ALIAS, connections, router from django.db.migrations.loader import MigrationLoader from migration_fixer.utils import ( fix_migration, fix_numbered_migration, no_translations, run_command, ) class Command(BaseCommand): success_msg = \"Successfully fixed migrations.\" def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser) @no_translations def handle(self, *app_labels, **options): self.merge = options[\"merge\"] self.fix = options[\"fix\"] self.default_branch = options[\"default_branch\"] if self.fix: try: super().handle(*app_labels, **options) except CommandError as e: [message] = e.args if \"Conflicting migrations\" in message: git_setup, git_setup_output, git_setup_error = run_command( \"git status\" ) if not git_setup: raise CommandError( self.style.ERROR( f\"VCS is not yet setup. \" \"Please run (git init) \" f'\\n\"{git_setup_output or git_setup_error}\"' ) ) ( get_current_branch, get_current_branch_output, get_current_branch_error, ) = run_command(\"git branch --show-current\") if not get_current_branch: raise CommandError( self.style.ERROR( f\"Unable to determine the current branch: \" f'\"{get_current_branch_output or get_current_branch_error}\"' ) ) pull_command = ( \"git pull\" if get_current_branch_output == self.default_branch else ( \"git fetch --depth=1 origin \" f\"{self.default_branch}:{self.default_branch}\" ) ) # Pull the last commit git_pull, git_pull_output, git_pull_error = run_command( pull_command ) if not git_pull: raise CommandError( self.style.ERROR( f\"Error pulling branch ({self.default_branch}) changes: \" f'\"{git_pull_output or git_pull_error}\"' ) ) head_sha, head_sha_output, head_sha_error = run_command( f\"git rev-parse {self.default_branch}\" ) if not head_sha: raise CommandError( self.style.ERROR( f\"Error determining head sha on ({self.default_branch}): \" f'\"{head_sha_output or head_sha_error}\"' ) ) # Load the current graph state. Pass in None for the connection so # the loader doesn't try to resolve replaced migrations from DB. loader = MigrationLoader(None, ignore_no_migrations=True) # Raise an error if any migrations are applied before their dependencies. consistency_check_labels = { config.label for config in apps.get_app_configs() } # Non-default databases are only checked if database routers used. aliases_to_check = ( connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS] ) for alias in sorted(aliases_to_check): connection = connections[alias] if connection.settings_dict[ \"ENGINE\" ] != \"django.db.backends.dummy\" and any( # At least one model must be migrated to the database. router.allow_migrate( connection.alias, app_label, model_name=model._meta.object_name, ) for app_label in consistency_check_labels for model in apps.get_app_config(app_label).get_models() ): loader.check_consistent_history(connection) # Before anything else, see if there's conflicting apps and drop out # hard if there are any and they don't want to merge conflicts = loader.detect_conflicts() app_labels = app_labels or tuple( app_label for app_label in settings.INSTALLED_APPS if app_label in conflicts ) for app_label in app_labels: conflict = conflicts.get(app_label) migration_module, _ = loader.migrations_module(app_label) migration_absolute_path = os.path.join( *migration_module.split(\".\") ) migration_path = pathlib.Path( os.path.join(settings.BASE_DIR, migration_absolute_path) ) with migration_path: ( get_changed_files, get_changed_files_output, get_changed_files_error, ) = run_command( f\"git diff --diff-filter=ACMUXTR --name-only {self.default_branch}\" ) if not get_changed_files: raise CommandError( self.style.ERROR( \"Error retrieving changed files on \" f\"({self.default_branch}): \" f'\"{get_changed_files_output or get_changed_files_error}\"' ) ) # Files different on the current branch changed_files = [ fname for fname in get_changed_files_output.split(\"\\n\") if migration_absolute_path in fname ] # Local migration local_filenames = [ os.path.splitext(os.path.basename(p))[0] for p in changed_files ] last_remote = [ fname for fname in conflict if fname not in local_filenames ] if not last_remote: raise CommandError( self.style.ERROR( f\"Unable to determine the last migration on: \" f\"{self.default_branch}\", ) ) last_remote_filename, *rest = last_remote changed_files = changed_files or [ f\"{fname}.py\" for fname in rest ] seed_split = last_remote_filename.split(\"_\") try: if ( seed_split and len(seed_split) > 1 and str(seed_split[0]).isdigit() ): fix_numbered_migration( app_label=app_label, migration_path=migration_path, seed=int(seed_split[0]), start_name=last_remote_filename, changed_files=changed_files, ) else: fix_migration( app_label=app_label, migration_path=migration_path, start_name=last_remote_filename, changed_files=changed_files, ) except (ValueError, IndexError, TypeError) as e: self.stderr.write(f\"Error: {e}\") else: self.stdout.write(self.success_msg) else: return super(Command, self).handle(*app_labels, **options)","title":"Module migration_fixer.management.commands.makemigrations"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#variables","text":"DEFAULT_DB_ALIAS","title":"Variables"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#classes","text":"","title":"Classes"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#command","text":"class Command ( stdout = None , stderr = None , no_color = False , force_color = False ) View Source class Command(BaseCommand): success_msg = \"Successfully fixed migrations.\" def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser) @no_translations def handle(self, *app_labels, **options): self.merge = options[\"merge\"] self.fix = options[\"fix\"] self.default_branch = options[\"default_branch\"] if self.fix: try: super().handle(*app_labels, **options) except CommandError as e: [message] = e.args if \"Conflicting migrations\" in message: git_setup, git_setup_output, git_setup_error = run_command( \"git status\" ) if not git_setup: raise CommandError( self.style.ERROR( f\"VCS is not yet setup. \" \"Please run (git init) \" f'\\n\"{git_setup_output or git_setup_error}\"' ) ) ( get_current_branch, get_current_branch_output, get_current_branch_error, ) = run_command(\"git branch --show-current\") if not get_current_branch: raise CommandError( self.style.ERROR( f\"Unable to determine the current branch: \" f'\"{get_current_branch_output or get_current_branch_error}\"' ) ) pull_command = ( \"git pull\" if get_current_branch_output == self.default_branch else ( \"git fetch --depth=1 origin \" f\"{self.default_branch}:{self.default_branch}\" ) ) # Pull the last commit git_pull, git_pull_output, git_pull_error = run_command( pull_command ) if not git_pull: raise CommandError( self.style.ERROR( f\"Error pulling branch ({self.default_branch}) changes: \" f'\"{git_pull_output or git_pull_error}\"' ) ) head_sha, head_sha_output, head_sha_error = run_command( f\"git rev-parse {self.default_branch}\" ) if not head_sha: raise CommandError( self.style.ERROR( f\"Error determining head sha on ({self.default_branch}): \" f'\"{head_sha_output or head_sha_error}\"' ) ) # Load the current graph state. Pass in None for the connection so # the loader doesn't try to resolve replaced migrations from DB. loader = MigrationLoader(None, ignore_no_migrations=True) # Raise an error if any migrations are applied before their dependencies. consistency_check_labels = { config.label for config in apps.get_app_configs() } # Non-default databases are only checked if database routers used. aliases_to_check = ( connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS] ) for alias in sorted(aliases_to_check): connection = connections[alias] if connection.settings_dict[ \"ENGINE\" ] != \"django.db.backends.dummy\" and any( # At least one model must be migrated to the database. router.allow_migrate( connection.alias, app_label, model_name=model._meta.object_name, ) for app_label in consistency_check_labels for model in apps.get_app_config(app_label).get_models() ): loader.check_consistent_history(connection) # Before anything else, see if there's conflicting apps and drop out # hard if there are any and they don't want to merge conflicts = loader.detect_conflicts() app_labels = app_labels or tuple( app_label for app_label in settings.INSTALLED_APPS if app_label in conflicts ) for app_label in app_labels: conflict = conflicts.get(app_label) migration_module, _ = loader.migrations_module(app_label) migration_absolute_path = os.path.join( *migration_module.split(\".\") ) migration_path = pathlib.Path( os.path.join(settings.BASE_DIR, migration_absolute_path) ) with migration_path: ( get_changed_files, get_changed_files_output, get_changed_files_error, ) = run_command( f\"git diff --diff-filter=ACMUXTR --name-only {self.default_branch}\" ) if not get_changed_files: raise CommandError( self.style.ERROR( \"Error retrieving changed files on \" f\"({self.default_branch}): \" f'\"{get_changed_files_output or get_changed_files_error}\"' ) ) # Files different on the current branch changed_files = [ fname for fname in get_changed_files_output.split(\"\\n\") if migration_absolute_path in fname ] # Local migration local_filenames = [ os.path.splitext(os.path.basename(p))[0] for p in changed_files ] last_remote = [ fname for fname in conflict if fname not in local_filenames ] if not last_remote: raise CommandError( self.style.ERROR( f\"Unable to determine the last migration on: \" f\"{self.default_branch}\", ) ) last_remote_filename, *rest = last_remote changed_files = changed_files or [ f\"{fname}.py\" for fname in rest ] seed_split = last_remote_filename.split(\"_\") try: if ( seed_split and len(seed_split) > 1 and str(seed_split[0]).isdigit() ): fix_numbered_migration( app_label=app_label, migration_path=migration_path, seed=int(seed_split[0]), start_name=last_remote_filename, changed_files=changed_files, ) else: fix_migration( app_label=app_label, migration_path=migration_path, start_name=last_remote_filename, changed_files=changed_files, ) except (ValueError, IndexError, TypeError) as e: self.stderr.write(f\"Error: {e}\") else: self.stdout.write(self.success_msg) else: return super(Command, self).handle(*app_labels, **options)","title":"Command"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#ancestors-in-mro","text":"django.core.management.commands.makemigrations.Command django.core.management.base.BaseCommand","title":"Ancestors (in MRO)"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#class-variables","text":"base_stealth_options help output_transaction requires_migrations_checks requires_system_checks stealth_options success_msg","title":"Class variables"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#methods","text":"","title":"Methods"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#add_arguments","text":"def add_arguments ( self , parser ) Entry point for subclassed commands to add custom arguments. View Source def add_arguments(self, parser): parser.add_argument( \"--fix\", action=\"store_true\", help=\"Fix migrations conflicts.\", ) parser.add_argument( \"-b\", \"--default-branch\", help=\"The name of the default branch.\", default=\"main\", ) super().add_arguments(parser)","title":"add_arguments"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#check","text":"def check ( self , app_configs = None , tags = None , display_num_errors = False , include_deployment_checks = False , fail_level = 40 , databases = None ) Use the system check framework to validate entire Django project. Raise CommandError for any serious message (error or critical errors). If there are only light messages (like warnings), print them to stderr and don't raise an exception. View Source def check(self, app_configs=None, tags=None, display_num_errors=False, include_deployment_checks=False, fail_level=checks.ERROR, databases=None): \"\"\" Use the system check framework to validate entire Django project. Raise CommandError for any serious message (error or critical errors). If there are only light messages (like warnings), print them to stderr and don't raise an exception. \"\"\" all_issues = checks.run_checks( app_configs=app_configs, tags=tags, include_deployment_checks=include_deployment_checks, databases=databases, ) header, body, footer = \"\", \"\", \"\" visible_issue_count = 0 # excludes silenced warnings if all_issues: debugs = [e for e in all_issues if e.level < checks.INFO and not e.is_silenced()] infos = [e for e in all_issues if checks.INFO <= e.level < checks.WARNING and not e.is_silenced()] warnings = [e for e in all_issues if checks.WARNING <= e.level < checks.ERROR and not e.is_silenced()] errors = [e for e in all_issues if checks.ERROR <= e.level < checks.CRITICAL and not e.is_silenced()] criticals = [e for e in all_issues if checks.CRITICAL <= e.level and not e.is_silenced()] sorted_issues = [ (criticals, 'CRITICALS'), (errors, 'ERRORS'), (warnings, 'WARNINGS'), (infos, 'INFOS'), (debugs, 'DEBUGS'), ] for issues, group_name in sorted_issues: if issues: visible_issue_count += len(issues) formatted = ( self.style.ERROR(str(e)) if e.is_serious() else self.style.WARNING(str(e)) for e in issues) formatted = \"\\n\".join(sorted(formatted)) body += '\\n%s:\\n%s\\n' % (group_name, formatted) if visible_issue_count: header = \"System check identified some issues:\\n\" if display_num_errors: if visible_issue_count: footer += '\\n' footer += \"System check identified %s (%s silenced).\" % ( \"no issues\" if visible_issue_count == 0 else \"1 issue\" if visible_issue_count == 1 else \"%s issues\" % visible_issue_count, len(all_issues) - visible_issue_count, ) if any(e.is_serious(fail_level) and not e.is_silenced() for e in all_issues): msg = self.style.ERROR(\"SystemCheckError: %s\" % header) + body + footer raise SystemCheckError(msg) else: msg = header + body + footer if msg: if visible_issue_count: self.stderr.write(msg, lambda x: x) else: self.stdout.write(msg)","title":"check"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#check_migrations","text":"def check_migrations ( self ) Print a warning if the set of migrations on disk don't match the migrations in the database. View Source def check_migrations(self): \"\"\" Print a warning if the set of migrations on disk don't match the migrations in the database. \"\"\" from django.db.migrations.executor import MigrationExecutor try: executor = MigrationExecutor(connections[DEFAULT_DB_ALIAS]) except ImproperlyConfigured: # No databases are configured (or the dummy one) return plan = executor.migration_plan(executor.loader.graph.leaf_nodes()) if plan: apps_waiting_migration = sorted({migration.app_label for migration, backwards in plan}) self.stdout.write( self.style.NOTICE( \"\\nYou have %(unapplied_migration_count)s unapplied migration(s). \" \"Your project may not work properly until you apply the \" \"migrations for app(s): %(apps_waiting_migration)s.\" % { \"unapplied_migration_count\": len(plan), \"apps_waiting_migration\": \", \".join(apps_waiting_migration), } ) ) self.stdout.write(self.style.NOTICE(\"Run 'python manage.py migrate' to apply them.\"))","title":"check_migrations"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#create_parser","text":"def create_parser ( self , prog_name , subcommand , ** kwargs ) Create and return the ArgumentParser which will be used to parse the arguments to this command. View Source def create_parser(self, prog_name, subcommand, **kwargs): \"\"\" Create and return the ``ArgumentParser`` which will be used to parse the arguments to this command. \"\"\" parser = CommandParser( prog='%s %s' % (os.path.basename(prog_name), subcommand), description=self.help or None, formatter_class=DjangoHelpFormatter, missing_args_message=getattr(self, 'missing_args_message', None), called_from_command_line=getattr(self, '_called_from_command_line', None), **kwargs ) parser.add_argument('--version', action='version', version=self.get_version()) parser.add_argument( '-v', '--verbosity', default=1, type=int, choices=[0, 1, 2, 3], help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output', ) parser.add_argument( '--settings', help=( 'The Python path to a settings module, e.g. ' '\"myproject.settings.main\". If this isn\\'t provided, the ' 'DJANGO_SETTINGS_MODULE environment variable will be used.' ), ) parser.add_argument( '--pythonpath', help='A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".', ) parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions') parser.add_argument( '--no-color', action='store_true', help=\"Don't colorize the command output.\", ) parser.add_argument( '--force-color', action='store_true', help='Force colorization of the command output.', ) if self.requires_system_checks: parser.add_argument( '--skip-checks', action='store_true', help='Skip system checks.', ) self.add_arguments(parser) return parser","title":"create_parser"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#execute","text":"def execute ( self , * args , ** options ) Try to execute this command, performing system checks if needed (as controlled by the requires_system_checks attribute, except if force-skipped). View Source def execute(self, *args, **options): \"\"\" Try to execute this command, performing system checks if needed (as controlled by the ``requires_system_checks`` attribute, except if force-skipped). \"\"\" if options['force_color'] and options['no_color']: raise CommandError(\"The --no-color and --force-color options can't be used together.\") if options['force_color']: self.style = color_style(force_color=True) elif options['no_color']: self.style = no_style() self.stderr.style_func = None if options.get('stdout'): self.stdout = OutputWrapper(options['stdout']) if options.get('stderr'): self.stderr = OutputWrapper(options['stderr']) if self.requires_system_checks and not options['skip_checks']: if self.requires_system_checks == ALL_CHECKS: self.check() else: self.check(tags=self.requires_system_checks) if self.requires_migrations_checks: self.check_migrations() output = self.handle(*args, **options) if output: if self.output_transaction: connection = connections[options.get('database', DEFAULT_DB_ALIAS)] output = '%s\\n%s\\n%s' % ( self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()), output, self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()), ) self.stdout.write(output) return output","title":"execute"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#get_version","text":"def get_version ( self ) Return the Django version, which should be correct for all built-in Django commands. User-supplied commands can override this method to return their own version. View Source def get_version(self): \"\"\" Return the Django version, which should be correct for all built-in Django commands. User-supplied commands can override this method to return their own version. \"\"\" return django.get_version()","title":"get_version"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#handle","text":"def handle ( * args , ** kwargs ) View Source def wrapped(*args, **kwargs): from django.utils import translation saved_locale = translation.get_language() translation.deactivate_all() try: res = handle_func(*args, **kwargs) finally: if saved_locale is not None: translation.activate(saved_locale) return res","title":"handle"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#handle_merge","text":"def handle_merge ( self , loader , conflicts ) Handles merging together conflicted migrations interactively, if it's safe; otherwise, advises on how to fix it. View Source def handle_merge(self, loader, conflicts): \"\"\" Handles merging together conflicted migrations interactively, if it's safe; otherwise, advises on how to fix it. \"\"\" if self.interactive: questioner = InteractiveMigrationQuestioner() else: questioner = MigrationQuestioner(defaults={'ask_merge': True}) for app_label, migration_names in conflicts.items(): # Grab out the migrations in question, and work out their # common ancestor. merge_migrations = [] for migration_name in migration_names: migration = loader.get_migration(app_label, migration_name) migration.ancestry = [ mig for mig in loader.graph.forwards_plan((app_label, migration_name)) if mig[0] == migration.app_label ] merge_migrations.append(migration) def all_items_equal(seq): return all(item == seq[0] for item in seq[1:]) merge_migrations_generations = zip(*(m.ancestry for m in merge_migrations)) common_ancestor_count = sum(1 for common_ancestor_generation in takewhile(all_items_equal, merge_migrations_generations)) if not common_ancestor_count: raise ValueError(\"Could not find common ancestor of %s\" % migration_names) # Now work out the operations along each divergent branch for migration in merge_migrations: migration.branch = migration.ancestry[common_ancestor_count:] migrations_ops = (loader.get_migration(node_app, node_name).operations for node_app, node_name in migration.branch) migration.merged_operations = sum(migrations_ops, []) # In future, this could use some of the Optimizer code # (can_optimize_through) to automatically see if they're # mergeable. For now, we always just prompt the user. if self.verbosity > 0: self.stdout.write(self.style.MIGRATE_HEADING(\"Merging %s\" % app_label)) for migration in merge_migrations: self.stdout.write(self.style.MIGRATE_LABEL(\" Branch %s\" % migration.name)) for operation in migration.merged_operations: self.stdout.write(' - %s' % operation.describe()) if questioner.ask_merge(app_label): # If they still want to merge it, then write out an empty # file depending on the migrations needing merging. numbers = [ MigrationAutodetector.parse_number(migration.name) for migration in merge_migrations ] try: biggest_number = max(x for x in numbers if x is not None) except ValueError: biggest_number = 1 subclass = type(\"Migration\", (Migration,), { \"dependencies\": [(app_label, migration.name) for migration in merge_migrations], }) parts = ['%04i' % (biggest_number + 1)] if self.migration_name: parts.append(self.migration_name) else: parts.append('merge') leaf_names = '_'.join(sorted(migration.name for migration in merge_migrations)) if len(leaf_names) > 47: parts.append(get_migration_name_timestamp()) else: parts.append(leaf_names) migration_name = '_'.join(parts) new_migration = subclass(migration_name, app_label) writer = MigrationWriter(new_migration, self.include_header) if not self.dry_run: # Write the merge migrations file to the disk with open(writer.path, \"w\", encoding='utf-8') as fh: fh.write(writer.as_string()) if self.verbosity > 0: self.stdout.write(\"\\nCreated new merge migration %s\" % writer.path) elif self.verbosity == 3: # Alternatively, makemigrations --merge --dry-run --verbosity 3 # will output the merge migrations to stdout rather than saving # the file to the disk. self.stdout.write(self.style.MIGRATE_HEADING( \"Full merge migrations file '%s':\" % writer.filename )) self.stdout.write(writer.as_string())","title":"handle_merge"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#print_help","text":"def print_help ( self , prog_name , subcommand ) Print the help message for this command, derived from self.usage() . View Source def print_help(self, prog_name, subcommand): \"\"\" Print the help message for this command, derived from ``self.usage()``. \"\"\" parser = self.create_parser(prog_name, subcommand) parser.print_help()","title":"print_help"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#run_from_argv","text":"def run_from_argv ( self , argv ) Set up any environment changes requested (e.g., Python path and Django settings), then run this command. If the command raises a CommandError , intercept it and print it sensibly to stderr. If the --traceback option is present or the raised Exception is not CommandError , raise it. View Source def run_from_argv(self, argv): \"\"\" Set up any environment changes requested (e.g., Python path and Django settings), then run this command. If the command raises a ``CommandError``, intercept it and print it sensibly to stderr. If the ``--traceback`` option is present or the raised ``Exception`` is not ``CommandError``, raise it. \"\"\" self._called_from_command_line = True parser = self.create_parser(argv[0], argv[1]) options = parser.parse_args(argv[2:]) cmd_options = vars(options) # Move positional args out of options to mimic legacy optparse args = cmd_options.pop('args', ()) handle_default_options(options) try: self.execute(*args, **cmd_options) except CommandError as e: if options.traceback: raise # SystemCheckError takes care of its own formatting. if isinstance(e, SystemCheckError): self.stderr.write(str(e), lambda x: x) else: self.stderr.write('%s: %s' % (e.__class__.__name__, e)) sys.exit(e.returncode) finally: try: connections.close_all() except ImproperlyConfigured: # Ignore if connections aren't setup at this point (e.g. no # configured settings). pass","title":"run_from_argv"},{"location":"reference/migration_fixer/management/commands/makemigrations.html#write_migration_files","text":"def write_migration_files ( self , changes ) Take a changes dict and write them out as migration files. View Source def write_migration_files(self, changes): \"\"\" Take a changes dict and write them out as migration files. \"\"\" directory_created = {} for app_label, app_migrations in changes.items(): if self.verbosity >= 1: self.stdout.write(self.style.MIGRATE_HEADING(\"Migrations for '%s':\" % app_label)) for migration in app_migrations: # Describe the migration writer = MigrationWriter(migration, self.include_header) if self.verbosity >= 1: # Display a relative path if it's below the current working # directory, or an absolute path otherwise. try: migration_string = os.path.relpath(writer.path) except ValueError: migration_string = writer.path if migration_string.startswith('..'): migration_string = writer.path self.stdout.write(' %s\\n' % self.style.MIGRATE_LABEL(migration_string)) for operation in migration.operations: self.stdout.write(' - %s' % operation.describe()) if not self.dry_run: # Write the migrations file to the disk. migrations_directory = os.path.dirname(writer.path) if not directory_created.get(app_label): os.makedirs(migrations_directory, exist_ok=True) init_path = os.path.join(migrations_directory, \"__init__.py\") if not os.path.isfile(init_path): open(init_path, \"w\").close() # We just do this once per app directory_created[app_label] = True migration_string = writer.as_string() with open(writer.path, \"w\", encoding='utf-8') as fh: fh.write(migration_string) elif self.verbosity == 3: # Alternatively, makemigrations --dry-run --verbosity 3 # will output the migrations to stdout rather than saving # the file to the disk. self.stdout.write(self.style.MIGRATE_HEADING( \"Full migrations file '%s':\" % writer.filename )) self.stdout.write(writer.as_string())","title":"write_migration_files"}]}